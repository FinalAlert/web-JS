1. Які переваги має використання ES6 класів порівняно з функціями-конструкторами?
Синтаксичний цукор: Класи в ES6 є більш зручними та читабельними, ніж функції-конструктори.
Наслідування: Класи підтримують ключові слова extends та super, що робить наслідування простішим і зрозумілішим.
Методи класу: Методи в класах автоматично додаються до прототипу об’єкта, що покращує продуктивність.
Чіткість коду: Класи краще структуровані, що полегшує розуміння та підтримку коду.

2. Як працює прототипне наслідування у JavaScript?
У JavaScript кожен об’єкт має приховану властивість [[Prototype]], яка посилається на інший об’єкт (його прототип).
Коли ви намагаєтеся отримати доступ до властивості або методу об’єкта, JavaScript спочатку шукає їх у самому об’єкті. Якщо їх немає, він шукає в прототипі об’єкта, потім у прототипі прототипа і так далі по ланцюжку прототипів.
Цей механізм називається прототипним наслідуванням.

3. Чим відрізняється контекст this в методах об’єктів від звичайних функцій?
У методах об’єктів this вказує на об’єкт, в якому викликано метод.
У звичайних функціях this залежить від контексту виклику:
У нестрогому режимі (non-strict mode) this вказує на глобальний об’єкт (наприклад, window у браузері).
У строгому режимі (strict mode) this буде undefined.

4. Як strict mode впливає на використання конструкторів?
У строгому режимі:
Якщо ви забудете використовувати new при виклику конструктора, this буде undefined, і це призведе до помилки. Це допомагає уникнути випадкового створення глобальних змінних.
Забороняється використовувати зарезервовані слова (наприклад, eval, arguments) як імена змінних або функцій.

5. Які переваги використання геттерів та сеттерів для інкапсуляції?
Контроль доступу: Геттери та сеттери дозволяють контролювати, як властивості об’єкта читаються та змінюються.
Валідація даних: Ви можете додати перевірки в сеттери, щоб уникнути некоректних значень.
Обчислювані властивості: Геттери дозволяють обчислювати значення властивостей на льоту.
Приховування реалізації: Ви можете приховати внутрішню реалізацію об’єкта, надаючи доступ лише через геттери та сеттери.

6. Як уникнути проблем із втратою контексту this при передачі методів?
Використовуйте bind():
const boundMethod = obj.method.bind(obj);
boundMethod(); // Контекст `this` буде збережено.
Використовуйте стрілкові функції:
const obj = {
    name: "Iван",
    greet: () => {
        console.log(`Привіт, мене звуть ${this.name}`);
    }
};
У стрілкових функціях this завжди береться з контексту, де вони були створені.

7. Які аспекти класичного OOP (інкапсуляція, поліморфізм, абстракція) підтримуються в JavaScript, а які – лише частково?
Інкапсуляція:
Підтримується частково. JavaScript не має повної приватності на рівні мови, але ви можете використовувати закриті поля (через # у класах) або угоду про приватність (наприклад, _name).
Поліморфізм:
Підтримується. JavaScript дозволяє перевизначати методи в дочірніх класах і використовувати їх через механізм прототипів.
Абстракція:
Підтримується частково. JavaScript не має вбудованої підтримки абстрактних класів або інтерфейсів, але ви можете імітувати їх за допомогою класів і методів.
Наслідування:
Підтримується через прототипи та класи (з використанням extends і super).
